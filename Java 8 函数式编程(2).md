# iRead 《Java 8 函数式编程》

## 类库

- 使用为基本类型定制的Lambda 表达式和Stream，如 IntStream 可以显著提升系统性能
- 默认方法指接口中定义的包含方法体的方法，具有```default```关键字前缀
- 在一个值可能为空的建模情况下，使用```Optional```对象能替代使用```null```

Java 8 中的另一个变化是引入了*默认方法*和接口的静态方法，它改变了人们认识类库的方式，接口中的方法也可以包含代码体了。

### 在代码中使用 Lambda 表达式

从调用的角度来看，Lambda 表达式和调用一个普通接口方法没有什么区别。

不同的函数接口有不同的方法，比如使用Predicate，就用```test```方法，若使用Function，就使用```apply```方法。

### 基本类型（Primitives）

基本类型（int）内建在语言和运行环境中，是基本的程序构建模块，而装箱类型（Integer）属于普通的 Java 类，只不过是对基本类型的一种封装。

Java 的泛型是基于对泛型参数类型的擦除，它是 Object 对象的实例，因此只有装箱类型才能作为泛型的参数。但是，由于装箱类型是对象，因此在内存中存在额外开销。

**装箱**：将基本类型转化为装箱类型，反之称为**拆箱**，两者都需要额外计算开销。

为了减少这些性能开销，Stream 类的某些方法对基本类型和装箱类型做了区分。Java 8 中，仅对整型、长整型和双浮点型做了特殊处理，因为它们在数值计算中用得最多，处理后的系统性能提升效果最明显。

对基本类型做特殊处理的方法在命名上由明确规范：

- 如果方法返回类型为基本类型，则基本类型前加 To，如 ToLongFunction
- 如果参数是基本类型，则不加前缀只需类型名即可，如 LongFunction
- 如果高阶函数使用基本类型，则在操作后加后缀To 再加基本类型，如 mapToLong

这些基本类型都有与之对应的Stream，以基本类型名为前缀，如 LongStream。

如由可能，应尽可能多地使用对基本类型做特殊处理的方法，进而改善性能。这些特殊的Stream 还提供额外的方法，避免重复实现一些通用的方法，让代码更能体现数值计算的意图。

mapToInt 返回一个IntStream 对象，包含```summaryStatistics```方法，这个方法能计算出各种各样的统计值。

三种基本类型（int, double, long）对应的特殊处理的Stream都用这些统计方法。

### 重载解析

Java 中可以重载，造成多个方法有相同的方法名，但签名不同。在推断参数类型时，会带来问题。这时，javac 会挑出*最具体*的类型。

推导过程遵循如下规则：
- 如果只有一个可能目标类型，由相应函数接口的参数类型推导得出；
- 如果有多个可能的目标类型，由最具体的类型推导得出；
- 如果有多个可能的目标类型且最具体的类型不明确，则需认为指定类型（强转）。

### ```@FunctionalInerface```注释

事实上，每个用作函数接口的接口都应该添加这个注释。
有些对象内部可能保存着某种状态，使用带有一个方法的接口纯属巧合，并不是为了使用 Lambda 表达式来实现的。

- ```java.lang.Comparable```: 如果一个类是可比较的，那么该类的实例之间存在某种顺序，比如字母序，但函数通常不认为是可比较的。
- ```java.io.Closeable```: 一个可关闭的对象必须持有某种打开的资源，比如需要关闭的文件句柄。这个接口也不可能是一个纯函数。

注释会强制javac 检查一个接口是否符合函数接口的标准。重构代码时，使用它也更容易发现问题。

### 二进制接口的兼容性

Java 8 中对API最大的改变在于集合类。虽然Java 在持续演进，但它一直在保持着向后二进制兼容。使用1 - 7 编译的类库或应用，可以之间在 8 上运行。

Java 8 中为Collection 接口新增了 stream 方法，着就意味着，所有实现了Collection接口的类都必须增加这个新方法。
虽然打破了二进制兼容性，在JDK 之外实现Collection 接口的类， 如MyCustomList 也仍然需要实现这个新增的stream 方法。。

这时所有第三方集合类库的梦魇，要避免这个糟糕情况，则需在Java 8 中添加新的语言特定：**默认方法**

### 默认方法

使用关键字 ```default```，接口中定义该方法，继承及实现都可调用。

- 类胜于接口
- 子类胜于父类

### 权衡

很多人认为多重继承的问题在于对象状态的继承，而不是代码快的继承，默认方法避免了状态的继承

接口刻意多重继承，却没有成员变量；抽象类可以继承成员变量，却不能多重继承。

抽象类：不能被实例化，只能被继承。可以有抽象方法，但，继承时必须实现该方法，除非子类也是抽象类。有抽象方法的一定是抽象类，反之不然。

### 接口的静态方法

Stream 是个接口， Stream.of 是接口的静态方法。

### ```Optional``` 对象

```reduce``` 方法有两种形式：
- 要初始值
- 不要初始值，第一步使用Stream 中的前两个元素。有时操作不存在有意义的初始值，此时返回一个```Optional```对象。

Optional 是为核心类库设计的一个数据类型，用来替换 ```null```值。
```null```代表值不存在的最大问题是，NullPointerException,一旦引用一个存储```null```值的变量，程序会立刻崩溃。

- ```Optional```对象鼓励程序员适时检查变量是否是空，一面代码缺陷
- 它将一个类的API中可能为空的值文档化，比阅读实现代码要简明多了。

```Optional```对象相当于值的容器，而该值刻意通过```get```方法提取。

```java
    Optional<String> a = Optional.of("a");
    assertEquals("a",a.get());
```

工厂方法

- ```empty``` 对应空值 （Optional.empty()）
- ```ofNullable``` 转化为Optional对象
- ```isPresent``` 检查对象是否有值
- ```orElse``` 当对象为空，提供了一个备选值
- ```orElseGet``` 当备选在计算上太过复杂，接受一个Supplier 对象。（```() -> "c"```）

## 高级集合类和收集器
- 方法引用是一种引用方法的轻量级语法
- 收集器可用来计算流的最终值，是reduce方法的模拟
- Java 8 提供了收集多种容器类型的方式，同时允许用户自定义收集器。

Java 8 对集合类的改进还包括新引入的```Collector```类。

### 方法引用（Method Reference）

Lambda 表达式有一种常见的用法： Lambda 表达式经常调用参数。比如

```java
artist -> artist.getName()
```
可以用Java 8提供的简写语法：方法引用（```Classname::methodName```）。来帮助程序员重用已有方法。

```java
Artist::getName
```

凡是用Lambda表达式的地方，就可以使用方法引用。

构造函数也有同样的缩写形式：

```java
(name, nationality) -> new Artist(name, nationality)

Artist::new
```
方法引用自动支持多个参数，前提是选对了正确的函数接口。

还可以用这种方式创建数组：

```java
String[]::new
```

### 元素顺序

流中的元素是按顺序处理的，成为*出现顺序*。

如果集合本身是无序的，由此产生的流也是无序的。

这样就会带来一些意想不到的结果，比如使用并行流时，```forEach```方法不能保证元素是按顺序处理的，如果要保证按顺序处理，应该使用```forEachOrdered```方法。

### 使用收集器

一种通用的、从流生成复杂值的结构。只将它传给```collect```方法，所有的流就都可以使用它了。

### 转换成其他集合

|方法|结果|
|:-|:-|
|```toList```|```java.util.List```|
|```toSet```|```Set```|
|```toCollection```|```Collection```|

但是，调用```toSet```或```toList```方法没有指定具体类型。如果不想要Stream类库在背后自动为你挑选类型，可以使用```toCollection```，它接受一个函数作为参数，来创建集合。

```java
stream.collect(toCollect(TreeSet::new));
```

### 转换成值
- ```maxby```
- ```minby```
- ```averagingInt```
- ```summingInt```

可以利用收集器让流生成一个值。

### 数据分块

收集器：```partitioningBy```

将流分解成两个集合。

接受一个流，将其分成两个部分。使用```Predicate```对象判断一个元素应该属于哪个部分，并根据布尔值返回一个```Map```到列表。

```java
public Map<Boolean, List<Artist>> bandsAndSolo(Stream<Artist> artists) {
    return artists.collect(partitioningBy(Artist::isSolo));
}
```

### 数据分组
收集器：```groupingBy```

将流分成任意对数据分组。
使用```Functional```对象，和```map```用到的操作一样。

### 字符串

很多时候，收集流中的数据都是为了在最后生成一个字符串。

以往可以用```StringBuilder```来记录结果。

```java
StringBuilder builder = new StringBuiler("[");

for (Artist artist: artists) {
    if (builder.length() > 1){
        builder.append(", ")
    }
    String name = artist.getName();
    builder.append(name);
}
builder.append("]");
String result = builder.toString();
```

使用流：

```java
String result = artists.stream().map(Artist::getName).collect(Collectors.joining(",","[","]"));
```
这里的```joining```函数允许用户提供分隔符、前缀、后缀。


### 组合收集器

将前面的各种收集器组合起来，会变得更加强大。
比如说```groupingBy```里面使用```counting```，可以计数。

```java
public Map<Artist, Long> numberOfAlbums(Stream<Album> albums) {
    return albums.collect(groupingBy(Album::getMainMusician, counting()))
}
```

```mapping```收集器可以将```groupingBy```的值作映射。需要指定用什么样的集合类存储结果。

```java
public Map<Artist, List<String>> nameOfAlbums(Stream<Album> albums){
    return albums.collect(groupingBy(Album::getMainMusician, mapping(Album::getName, toList())));
}
```

像这种，用以收集最终结果的一个自己的收集器，叫*下游收集器*。

收集器是生成最终结果的一剂配方，下游收集器则是生成部分结果的配方，主收集器中会用到下游收集器。

### 重构和定制收集器

一个收集器由四部分组成

- 一个Supplier，用于创建容器
- 一个accumulator 将当前元素叠加到收集器中
- 一个combiner 将多个容器合并成一个
- 一个finisher 输出结果

还有就是特征 ```characteristics```方法，描述一组收集器的对象，框架可以对其适当优化。

如果最终结果和容器一样，收集的最终结果就是集合，比如```toList```收集器，那么```finisher```不作任何操作，或者更正式的说，此时的```finisher```是```identity```函数，它返回传入参数的值。这样的话，收集器展现出```IDENTITY_FINISH```特征，用```characteristics```方法声明。

### 对收集器的归一化处理。

如果想为自己领域内的类定制一个收集器，不妨考虑一下其他替代方案。最容易想到的方案是构建若干个集合对象，作为参数传给领域内类的构造函数。如果领域内类包含多种集合，这种方法既简单又适用。

还可以使用```reducing```收集器，它为流上的归一操作提供了统一的实现。

和```reduce```操作很像，但是这种方式非常低效，这也是要定制收集器的原因之一。

### 一些细节
构建```Map```可以实现一个缓存。传统的处理方式是先试着从```Map```中取值，如果没有取到，创建一个新值并返回。

提供的```computeIfAbsent(item, this::DB)```提供了同样的功能。

还有，可能会在```Map```上作迭代，新增的```forEach```方法，可以通过编写内部迭代，便于阅读代码。

```java
Map<Artist, Integer> countOfAlbums = new HashMap<>();
albumsByArtist.forEach((artist, albums) -> {
    countOfAlbums.put(artist, albums.size());
});
```


## 数据并行化

- 数据并行化是把工作拆分，同时在多核CPU上执行的方式
- 如果使用流编写代码，可以通过调用```parallel```或者```parallelStream```方法实现数据并行化操作。
- 影响性能的五大要素。

告诉计算机做什么和怎么做是完全不同的，而Lambda 表达式和流可以告诉计算机做什么。
从外部迭代到内部迭代的过度，确实让编写简洁的代码更加容易，而且程序员不需要手动控制迭代过程了。迭代过程不是非要串行化，通过改动一个调用来告诉计算机我们的意图，就会出现一个类库指明我们怎么做。

### 并行和并发 （Parallelism Versus Concurrency）

- **并发**（Parallelism）：两个任务共享时间段，CPU 分配了不同的时间片。
- **并行**（Concurrency）：两个任务在同一时间发生，比如运行在多核 CPU 上。

并行化是指为缩短任务执行时间，将一个任务分解成几部分，然后并行执行。这和顺序执行的任务量是一样的。

- *数据并行化*：一种特殊的并行化。将数据分成块，并为每块数据分配单独的处理单元。
- *任务并行化*：线程不同，工作各异。常遇到的Java EE 应用容器便是任务并行化的例子之一。每个线程不光可以为不同用户服务，还可以为同一个用户执行不同的任务，比如登录或往购物车添加商品。

### 为什么并行化如此重要

现代 CPU 的架构转向了多核处理器，所以只能编写并行化的代码来提升运算能力。

阿姆达尔定律，问题的求解时间将完全取决于它可以被分解成几个部分。

### 并行化流操作

并行化操作流只需要改变一个方法调用。（```parallel```方法）
如果想从一个集合类创建一个流，调用 ```parallelStream``` 就能立即获得一个拥有并行能力的流。

将手头上代码中的```stream```方法替换为```parallelStream```方法即可，然而流类库的数据并行化只是其中的一种形式。

输入流的大小并不是决定并行化是否会带来速度提升的唯一因素，性能还会受到编写代码的方式和核的数量的影响。

### 模拟系统

并行化流操作的用武之地是使用简单操作处理大量数据，比如模拟系统。

### 限制

```reduce``` 初值必须为组合函数的恒等值。操作必须符合结合律。

### 性能

|影响因素|原    因|
|:----------|:-------|
|数据大小|将问题分解之后并行化处理，在将结果合并会带来额外的开销。只有数据足够达，么个数据处理管道花费时间足够多，才有并行化处理意义|
|源数据结构|将不同的数据源分割相对容易|
|装箱|处理基本类型比处理装箱类型要快|
|核的数量|只有一个核，完全没必要并行化。核的数量，不单指你的机器上有多少核，更是指运行时你的机器能使用多少核。|
|单元处理开销|比如数据大小，这是一场执行花费时间核分解合并操作开销之间的战争。花在流中的每个元素身上的时间越长，并行操作带来的性能提升越明显。|

fork/join 是并行流沿用的框架。fork 递归式分解问题，然后每段并行执行，最终由join合并结果，返回最后的值。

根据问题的分解方式，初始值的特性变得尤为重要
- ```ArrayList```、数组、```IntStream.range```，这些数据结构支持随机存储，所以容易分解
- ```HashSet```、```TreeSet```，这些数据结构不容易公平地分解，但是大多数时候分解是可能的。
- ```LinkedList```、```Streams.iterate```、```BufferedReader.lines```对半分解太难，长度未知。

流中单独操作每一块的种类时，可以分成两种不同的操作：
- *无状态的* 无状态可以不必维护，比如 ```map```、```filter```、```flatMap```。
- *有状态的* 有状态则需维护开销和限制，比如 ```sorted```、```distinct```、```limit```。

### 并行化数组操作

脱离流框架也可以使用Lambda 表达式。这些操作也是正对数据的并行化操作。

|方法名|操作|
|:--|:--|
|```parallelPrefix```|任意给定一个函数，计算数组的和|
|```parallelSet```|使用Lambda 表达式更新数组元素|
|```parallelSort```|并行化对数组元素排序|

