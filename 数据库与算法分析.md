# iRead 《数据库与算法分析》

## Java 基础

简单的泛型类和接口，当指定一个泛型类时，类的声明则包含一个或多个*类型参数*，这些参数被放到类名后面的一对尖括号里。

```java
public class MemoryCell<AnyType>{
    public AnyType read(){
        return storedValue;
    }
    public void write( AnyType x ){
        storedValue = x;
    }

    private AnyType storedValue;
}
```
#### 带有限制的通配符
通配符用来表示参数类型的子类（或超类）
```java
public static double totalArea( Collection<? extends Shape> arr ) {}
```

#### 泛型 static 方法
泛型中的类型参数位于返回类型之前。
```java
public static <AnyType> boolean contains(AnyType [] arr, AnyType x){}
```

但是要考虑类型限界

```java
public static <AnyType extends Comparable> AnyType findMax() {}
```

加上通配符，最满意效果：
```java
public static <AnyType extends Comparable<? super AnyType>> AnyType findMax(){}
```



## 树

__大部分的操作平均运行时间$O(\log N)$__

主要的实现类型 ```TreeSet, TreeMap``` (BST)
 
自然定义方式：递归

- 高：node ($n_i$) 到 叶的路径长度
- 深度： $n_i$ 到 root 的长度

如果存在$n_1$ 到 $n_2$ 的路径，那么$n_1$与$n_2$ 为相互的祖先和后代。若$n_1\ne n_2$ 那么互为真祖先和后代。

## 实现

```java
    class TreeNode{
        Object element;
        TreeNode firstChild, nextSibling;
    }
``` 

- __先序遍历__：对节点的处理工作是在它的诸儿子节点被处理之前的。（ 先探到底 $O(N)$ ）
- __后序遍历__：一个节点的处理工作是在它诸儿子节点被计算后进行。

### 二叉树

实现：

```java
    class BinaryNode{
        Object element;
        BinaryNode left;
        BinaryNode right;
    }
```

用途： 编译器的设计领域

表达式树：树叶是操作数，如常数或变量名，而其他的节点为操作符。所以正好是二叉树。一个节点也可能只有一个儿子，如具有一目减算符。

可以通过递归地产生一个带括号的右表达式而得到一个中缀表达式。（左边，节点，右边）中序遍历。来打印

后序遍历（左，右，节点）

先序遍历（中，右，左）

- 后缀表达式转化为树

### 查找树ADT
性质：节点左边比它小，节点右边比它大

平均深度：$O(\log n)$

二叉树要求所有的项都能排序。要写一个一般的类。(interface Comparable) 实现其```compareTo```方法

另一种实现是用嵌套类

```java
private static class BinaryNode<AnyType>{
    public BinaryNode(AnyType element){
        this.BinaryNode(element, null, null);
    }

    public BinaryNode(AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt){
        element = theElement;
        left = lt;
        right = rt;
    }

    private AnyType element;
    private BinaryNode<AnyType> left;
    private BinaryNode<AnyType> right;
}
```

一个二叉查找树包含

- ```contains``` 方法
- ```findMin``` 和 ```findMax``` 方法
- ```insert``` 方法
- ```remove``` 方法

若节点是一片叶，那么它可以被立即删除。若有一个儿子，则该节点可以在其父节点跳过自己的链以绕过该节点之后被删除。若有两个儿子，用右子树中的最小的数据代替该节点的数据，并递归删除那个节点。


一棵树的所有节点深度的和称为内部路径长。

#### 平衡查找树AVL树

带有平衡条件的二叉查找树，这个平衡条件必须要容易保持。
但是这种想法并不强求树的深度要浅。

另一种平衡条件是每个节点都必须有相同的高度的左子树和右子树。如果空子树的高度为$-1$，那么只具有$2^k-1$个节点的理想平衡树满足该条件。

定义：每个节点的左子树和右子树的高度最多差$1$的二叉查找树。一个AVL树的高度最多为 $1.44\times \log (N+2) - 1.328$

在高度为 $h$ 的AVL树中，最少节点 $S(h) = S(h-1) + S(h-2) + 1$给出。

插入一个节点可能破坏AVL树的特性，那么就要在考虑这一步插入完成之前恢复平衡的性质。例如通过简单的旋转。

插入以后，只有那些从插入点到根节点的路径上的节点的平衡才能被改变。把必须重新平衡的节点叫做 $\alpha$ ,由于任意节点最多有两个儿子，因此出现高度不平衡就需要 $\alpha$ 点的两棵子树的高度差 2。

