# iRead 《数据库与算法分析》
## 树

__大部分的操作平均运行时间$O(\log N)$__

主要的实现类型 ```TreeSet, TreeMap``` (BST)
 
自然定义方式：递归

- 高：node ($n_i$) 到 叶的路径长度
- 深度： $n_i$ 到 root 的长度

如果存在$n_1$ 到 $n_2$ 的路径，那么$n_1$与$n_2$ 为相互的祖先和后代。若$n_1\ne n_2$ 那么互为真祖先和后代。

## 实现

```java
    class TreeNode{
        Object element;
        TreeNode firstChild, nextSibling;
    }
``` 

- __先序遍历__：对节点的处理工作是在它的诸儿子节点被处理之前的。（ 先探到底 $O(N)$ ）
- __后序遍历__：一个节点的处理工作是在它诸儿子节点被计算后进行。

### 二叉树

实现：

```java
    class BinaryNode{
        Object element;
        BinaryNode left;
        BinaryNode right;
    }
```

用途： 编译器的设计领域

表达式树：树叶是操作数，如常数或变量名，而其他的节点为操作符。所以正好是二叉树。一个节点也可能只有一个儿子，如具有一目减算符。

可以通过递归地产生一个带括号的右表达式而得到一个中缀表达式。（左边，节点，右边）中序遍历。来打印

后序遍历（左，右，节点）

先序遍历（中，右，左）

- 后缀表达式转化为树

### 查找树ADT
性质：节点左边比它小，节点右边比它大

平均深度：$O(\log n)$

二叉树要求所有的项都能排序。要写一个一般的类。(interface Comparable) 实现其```compareTo```方法

另一种实现是用嵌套类

```java
private static class BinaryNode<AnyType>{
    public BinaryNode(AnyType element){
        this.BinaryNode(element, null, null);
    }

    public BinaryNode(AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt){
        element = theElement;
        left = lt;
        right = rt;
    }

    private AnyType element;
    private BinaryNode<AnyType> left;
    private BinaryNode<AnyType> right;
}
```

